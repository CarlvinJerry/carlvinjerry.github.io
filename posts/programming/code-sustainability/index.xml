<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Code Sustainability on RΞCURSION</title><link>https://carlvinjerry.github.io/posts/programming/code-sustainability/</link><description>Recent content in Code Sustainability on RΞCURSION</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://carlvinjerry.github.io/posts/programming/code-sustainability/index.xml" rel="self" type="application/rss+xml"/><item><title> Optimizing Pattern Matching in F# for Better Performance</title><link>https://carlvinjerry.github.io/posts/programming/code-sustainability/succint-fsharp/pattern-matching/</link><pubDate>Mon, 03 Mar 2025 21:37:25 +0600</pubDate><guid>https://carlvinjerry.github.io/posts/programming/code-sustainability/succint-fsharp/pattern-matching/</guid><description>Pattern matching is one of the most powerful features of functional we can employ to ensure more expressive and easier-to-read code. However, handling large data structures may require optimal pattern matching to avoid performance. This article explores techniques to optimize pattern matching in F# by minimizing unnecessary computations and improving efficiency.
Common Performance Issues in Pattern Matching Although pattern matching improves code readability, improper use can lead to inefficiencies. Some common issues include:</description></item><item><title>Memoization with Fibonacci</title><link>https://carlvinjerry.github.io/posts/programming/code-sustainability/succint-fsharp/memoization/</link><pubDate>Mon, 04 Nov 2024 21:37:25 +0600</pubDate><guid>https://carlvinjerry.github.io/posts/programming/code-sustainability/succint-fsharp/memoization/</guid><description>Memoization, commonly known as caching is a key technique we can use for performance optimization in programming. Memoization simply stores the results from a previous computation for later retrieval whenever the arguments are presented again. The ability to re-use these, often expensive functions, brings significant performance improvements - especially in scenarios with repetitive computations. In F#, memoization is not only a helpful optimization but also a natural fit due to the language’s immutable data structures and functional nature.</description></item><item><title>A Better Way to Manage Dependencies in F#</title><link>https://carlvinjerry.github.io/posts/programming/code-sustainability/succint-fsharp/working-with-paket/</link><pubDate>Tue, 22 Oct 2024 21:37:25 +0600</pubDate><guid>https://carlvinjerry.github.io/posts/programming/code-sustainability/succint-fsharp/working-with-paket/</guid><description>The default go-to tool for most .Net developers is NuGet. It simplifies handling dependencies across projects and also provides a central reference point for reusable .Net components. Due to its initial development and growth over time, NuGet poses a few shortcomings evident over the years. As an alternative, specifically for F# developers, Paket is an open source dependency manager for .Net projects that was originally built with the primary goal of addressing some of the shortcomings developers encountered when managing dependencies in large and complex projects.</description></item><item><title>Currying and Partial Application in F#</title><link>https://carlvinjerry.github.io/posts/programming/code-sustainability/succint-fsharp/currying/</link><pubDate>Mon, 07 Oct 2024 08:06:25 +0600</pubDate><guid>https://carlvinjerry.github.io/posts/programming/code-sustainability/succint-fsharp/currying/</guid><description>The mathematical definition of a function can be denoted as a relationship between a set of inputs (the domain) and a single output (the co-domain). When a mathematical function is said to have only one parameter, it typically means that it takes a single value as input. However, in functional programming we build functions that theoretically &amp;ldquo;defy&amp;rdquo; this concept by taking in multiple input parameters.
Traditionally, a mathematical function may only accept one input at a time.</description></item><item><title>Enhancing Code Maintainability with the F# 'Option' Type</title><link>https://carlvinjerry.github.io/posts/programming/code-sustainability/succint-fsharp/fs-option-type/</link><pubDate>Tue, 17 Sep 2024 08:06:25 +0600</pubDate><guid>https://carlvinjerry.github.io/posts/programming/code-sustainability/succint-fsharp/fs-option-type/</guid><description>A common case in programming is handling variables that might or might not hold a value. The C# language for example, uses Nullable&amp;lt;T&amp;gt; to represent such cases. This enables you to declare variables as nullables that would otherwise not be assigned to Nulls (e.g a float or an int). Handling these null references in languages like C# or Java can often lead to bugs. A clean and powerful solution to this problem is provided in F#: the Option type.</description></item><item><title>Mastering Python's Exceptional Complexity</title><link>https://carlvinjerry.github.io/posts/programming/code-sustainability/error-handling/python-exceptions/</link><pubDate>Thu, 14 Sep 2023 06:00:20 +0600</pubDate><guid>https://carlvinjerry.github.io/posts/programming/code-sustainability/error-handling/python-exceptions/</guid><description>Introduction Exception handling is a fundamental pillar of programming, and Python in particular, excels in this area given its robust and versatile error management system. A program terminates immediately it encounters an error, typically taking one of two forms: syntax errors and exceptions. In this article, we&amp;rsquo;ll demystify exceptions, distinguishing them from syntax errors, and explore the art of effectively managing them. Finally, we will look at some advanced techniques coupled with best practices for gracefully handling exceptions.</description></item></channel></rss>