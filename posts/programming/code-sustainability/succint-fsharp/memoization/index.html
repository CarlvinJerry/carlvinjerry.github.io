<!doctype html><html lang=en><head><title>Memoization with Fibonacci</title>
<meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><link rel=stylesheet href=/application.ffc4c7b40a84a6cc07476bf220dd79432177a593771276da69cb703d50fcac34.css integrity="sha256-/8THtAqEpswHR2vyIN15QyF3pZN3EnbaactwPVD8rDQ="><link rel=icon type=image/png href=/images/site/favicon_hu14458373468778497799.png><meta property="og:url" content="https://carlvinjerry.github.io/posts/programming/code-sustainability/succint-fsharp/memoization/"><meta property="og:site_name" content="RŒûCURSION"><meta property="og:title" content="Memoization with Fibonacci"><meta property="og:description" content="A Guide to Optimized Functional Programming with Memoization in F#"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-04T21:37:25+06:00"><meta property="article:modified_time" content="2025-08-18T17:45:06+03:00"><meta property="article:tag" content="F#"><meta property="article:tag" content="Optimization"><meta property="article:tag" content="Functional Programming"><meta property="article:tag" content="Caching"><meta property="article:tag" content="Software Development"><meta name=twitter:card content="summary"><meta name=twitter:title content="Memoization with Fibonacci"><meta name=twitter:description content="A Guide to Optimized Functional Programming with Memoization in F#"><meta name=description content="A Guide to Optimized Functional Programming with Memoization in F#"><script async src="https://www.googletagmanager.com/gtag/js?id=462784605"></script><script>var dnt,doNotTrack=!1;if(null&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","462784605")}</script><script src=https://cdn.counter.dev/script.js data-id=CarlvinJerry data-utcoffset=1></script><script data-goatcounter=https://carlvinjerry.goatcounter.com/count async src=//gc.zgo.at/count.js></script><script integrity="sha256-DO4ugzEwhTW1Id1UIWn0gUJWaebCYOypeTit6LW4QB4=">let theme=localStorage.getItem("theme-scheme")||localStorage.getItem("darkmode:color-scheme")||"light";theme==="system"&&(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?theme="dark":theme="light"),document.documentElement.setAttribute("data-theme",theme)</script></head><body class="type-posts kind-page" data-bs-spy=scroll data-bs-target=#TableOfContents data-bs-offset=80><div class="container-fluid bg-secondary wrapper"><nav class="navbar navbar-expand-xl top-navbar shadow" id=top-navbar><div class=container><button class="navbar-toggler navbar-light" id=sidebar-toggler type=button>
<i data-feather=sidebar></i>
</button>
<a class=navbar-brand href=/><img src=/images/site/main-logo_hu1754343916303502928.png id=logo alt=Logo>
RŒûCURSION</a>
<button class="navbar-toggler navbar-light" id=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#top-nav-items aria-label=menu>
<i data-feather=menu></i></button><div class="collapse navbar-collapse dynamic-navbar" id=top-nav-items><ul class="nav navbar-nav ms-auto"><li class=nav-item><a class=nav-link href=/#home>Home</a></li><li class=nav-item><a class=nav-link href=/#about>About</a></li><li class=nav-item><a class=nav-link href=/#recent-posts>Recent Posts</a></li><li class=nav-item><a class=nav-link href=/#projects>Projects</a></li><div id=top-navbar-divider></div><li class=nav-item><a class=nav-link id=blog-link href=/posts>Posts</a></li><li class=nav-item><a class=nav-link id=note-link href=/notes>Notes</a></li><li class=nav-item><a class=nav-link href=https://toha-guides.netlify.app/posts/>Docs</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=themeSelector role=button data-bs-toggle=dropdown aria-haspopup=true aria-expanded=false><img id=navbar-theme-icon-svg class=theme-icon src=/icons/moon-svgrepo-com.svg width=20 alt="Dark Theme"></a><div id=themeMenu class="dropdown-menu dropdown-menu-icons-only" aria-labelledby=themeSelector><a class="dropdown-item nav-link" href=# data-scheme=light><img class=theme-icon src=/icons/sun-svgrepo-com.svg width=20 alt="Light Theme">
</a><a class="dropdown-item nav-link" href=# data-scheme=dark><img class=theme-icon src=/icons/moon-svgrepo-com.svg width=20 alt="Dark Theme">
</a><a class="dropdown-item nav-link" href=# data-scheme=system><img class=theme-icon src=/icons/computer-svgrepo-com.svg width=20 alt="System Theme"></a></div></li></ul></div></div><img src=/images/site/main-logo_hu1754343916303502928.png class=d-none id=main-logo alt=Logo>
<img src=/images/site/inverted-logo_hu14458373468778497799.png class=d-none id=inverted-logo alt="Inverted Logo"></nav><section class=sidebar-section id=sidebar-section><div class=sidebar-holder><div class=sidebar id=sidebar><form class=mx-auto method=get action=/search><input type=text name=keyword placeholder=Search data-search id=search-box></form><div class=sidebar-tree><ul class=tree id=tree><li id=list-heading><a href=/posts/ data-filter=all>Posts</a></li><div class=subtree><li><a class=list-link href=/posts/introduction/ title=Introduction>Introduction</a></li><li><i data-feather=minus-circle></i><a class="active list-link" href=/posts/programming/> Programming</a><ul class=active><li><i data-feather=minus-circle></i><a class="active list-link" href=/posts/programming/code-sustainability/> Code Sustainability</a><ul class=active><li><i data-feather=plus-circle></i><a class=list-link href=/posts/programming/code-sustainability/error-handling/> Error Handling</a><ul><li><a class=list-link href=/posts/programming/code-sustainability/error-handling/python-exceptions/ title="Exception Handling in Python">Exception Handling in Python</a></li></ul></li><li><i data-feather=minus-circle></i><a class="active list-link" href=/posts/programming/code-sustainability/succint-fsharp/> Succint FSharp</a><ul class=active><li><a class=list-link href=/posts/programming/code-sustainability/succint-fsharp/currying/ title="Currying and Partial Application">Currying and Partial Application</a></li><li><a class=list-link href=/posts/programming/code-sustainability/succint-fsharp/working-with-paket/ title="A Better Way to Manage Dependencies in F#">A Better Way to Manage Dependencies in F#</a></li><li><a class="active list-link" href=/posts/programming/code-sustainability/succint-fsharp/memoization/ title="Memoization in F#">Memoization in F#</a></li><li><a class=list-link href=/posts/programming/code-sustainability/succint-fsharp/pattern-matching/ title="Pattern Matching in F#">Pattern Matching in F#</a></li><li><a class=list-link href=/posts/programming/code-sustainability/succint-fsharp/fs-option-type/ title="Understanding the F# Option Type">Understanding the F# Option Type</a></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/posts/programming/functional-programming/> Functional Programming</a><ul><li><a class=list-link href=/posts/programming/functional-programming/discriminated-unions/ title="Discriminated Unions in F#">Discriminated Unions in F#</a></li><li><a class=list-link href=/posts/programming/functional-programming/functional-programming/ title="Functional Programming Nuances">Functional Programming Nuances</a></li><li><a class=list-link href=/posts/programming/functional-programming/monads/ title="Functors and Monads in F#">Functors and Monads in F#</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/posts/programming/interoperability/> Interoperability</a><ul><li><a class=list-link href=/posts/programming/interoperability/rdotnet-interop/ title="R.NET Integration in .NET">R.NET Integration in .NET</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/posts/programming/languages/> Languages</a><ul><li><i data-feather=plus-circle></i><a class=list-link href=/posts/programming/languages/fsharp/> fsharp</a><ul><li><a class=list-link href=/posts/programming/languages/fsharp/fsharp-9-review/ title=fsharp-9-review>fsharp-9-review</a></li></ul></li></ul></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/posts/quantitative-finance/> Quantitative-Finance</a><ul><li><a class=list-link href=/posts/quantitative-finance/intro-to-sdes/ title="Introduction to SDEs">Introduction to SDEs</a></li><li><a class=list-link href=/posts/quantitative-finance/portfolio-risk-attribution/ title="Portfolio Risk Attribution">Portfolio Risk Attribution</a></li><li><a class=list-link href=/posts/quantitative-finance/moving-averages/ title="Simple Moving Average">Simple Moving Average</a></li></ul></li></div></ul></div></div></div></section><section class=content-section id=content-section><div class=content><div class="container p-0 read-area"><div class="hero-area col-sm-12" id=hero-area style=background-image:url(/posts/programming/code-sustainability/succint-fsharp/memoization/memory.jpg)></div><div class=page-content><div class="author-profile ms-auto align-self-lg-center"><img class=rounded-circle src=/images/author/j5_hu8605642293593435631.jpg alt="Author Image"><h5 class=author-name>Carlvin Jerry Mwange</h5><p class=text-muted>Monday, November 4, 2024 | 10 minutes</p></div><div class=title><h1>Memoization with Fibonacci</h1></div><div class=tags><ul style=padding-left:0><li class=rounded><a href=/tags/f#/ class="btn btn-sm btn-info">F#</a></li><li class=rounded><a href=/tags/optimization/ class="btn btn-sm btn-info">Optimization</a></li><li class=rounded><a href=/tags/functional-programming/ class="btn btn-sm btn-info">Functional Programming</a></li><li class=rounded><a href=/tags/caching/ class="btn btn-sm btn-info">Caching</a></li><li class=rounded><a href=/tags/software-development/ class="btn btn-sm btn-info">Software Development</a></li></ul></div><div class=post-content id=post-content><p><strong>Memoization</strong>, commonly known as caching is a key technique we can use for performance optimization in programming. Memoization simply stores the results from a previous computation for later retrieval whenever the arguments are presented again. The ability to re-use these, often expensive functions, brings significant performance improvements - especially in scenarios with repetitive computations. In F#, memoization is not only a helpful optimization but also a natural fit due to the language‚Äôs <em><strong>immutable</strong></em> data structures and functional nature. In this post, we‚Äôll take a deep dive into memoization, its benefits, and how to implement it in F#.</p><h4 id=why-memoization-matters>Why Memoization Matters</h4><p>In memoization,the results of function calls are stored in a lookup table or dictionary so that repeated calls with the same inputs can be served directly from the cache. This technique is particularly beneficial in situations where:</p><ul><li>The function is called multiple times with the same input values.</li><li>The function performs computationally expensive operations.</li><li>The results of the function calls are deterministic i.e, they consistently return the same output for the same input.</li></ul><p>Technically, memoization is useful in various applications:</p><ul><li><strong>Recursive Algorithms</strong>: Recursive functions like the Fibonacci sequence or factorial calculations benefit from memoization since they frequently recalculate the same values.</li><li><strong>Dynamic Programming</strong>: Memoization helps to optimize many dynamic programming problems, where subproblems overlap.</li><li><strong>Data Processing</strong>: Data pipelines with functions that process complex datasets can benefit from memoization to avoid redundant calculations.</li></ul><h3 id=basic-memoization-in-f>Basic Memoization in F#</h3><p>In F#, we can create memoized functions using higher-order functions and immutable collections. In the code below, we start by implementing a simple memoization function that uses a dictionary to store computed results. This dictionary serves as our cache, holding key-value pairs where the keys are function inputs and the values are computed outputs:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fsharp data-lang=fsharp><span style=display:flex><span><span style=color:#66d9ef>let</span> memoize f <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> cache <span style=color:#f92672>=</span> System.Collections.Generic.Dictionary<span style=color:#f92672>&lt;_,</span> <span style=color:#f92672>_&gt;</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fun</span> x <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> cache<span style=color:#f92672>.</span>ContainsKey<span style=color:#f92672>(</span>x<span style=color:#f92672>)</span> <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>            cache<span style=color:#f92672>.[</span>x<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> f x
</span></span><span style=display:flex><span>            cache<span style=color:#f92672>.[</span>x<span style=color:#f92672>]</span> <span style=color:#f92672>&lt;-</span> result
</span></span><span style=display:flex><span>            result
</span></span></code></pre></div><p>In the function above, we first take an input function f and return a new function that checks if a result is already cached. If the result is in the cache, it is returned immediately. Else, the function computes the result, stores it in the cache and then returns it.</p><h3 id=advanced-memoization-with-higher-order-functions>Advanced Memoization with Higher-Order Functions</h3><p>While the basic <code>memoize</code> function above works for single-argument functions, many real-world functions take multiple arguments. In F#, we can extend our <code>memoization</code> technique to handle multiple parameters using tuples as dictionary keys.</p><p>Here‚Äôs how we can create a memoized function that handles multiple arguments:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fsharp data-lang=fsharp><span style=display:flex><span><span style=color:#66d9ef>let</span> memoizeMultiArgs f <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> cache <span style=color:#f92672>=</span> System.Collections.Generic.Dictionary<span style=color:#f92672>&lt;_,</span> <span style=color:#f92672>_&gt;</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fun</span> x y <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> key <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>x<span style=color:#f92672>,</span> y<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> cache<span style=color:#f92672>.</span>ContainsKey<span style=color:#f92672>(</span>key<span style=color:#f92672>)</span> <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>            cache<span style=color:#f92672>.[</span>key<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> f x y
</span></span><span style=display:flex><span>            cache<span style=color:#f92672>.[</span>key<span style=color:#f92672>]</span> <span style=color:#f92672>&lt;-</span> result
</span></span><span style=display:flex><span>            result
</span></span></code></pre></div><h4 id=example-memoizing-a-multi-argument-function>Example: Memoizing a Multi-Argument Function</h4><p>Consider a function <code>power</code>, that computes x raised to the power of y. Memoizing this function can help reduce redundant computations when the same arguments are encountered multiple times:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fsharp data-lang=fsharp><span style=display:flex><span><span style=color:#66d9ef>let</span> power x y <span style=color:#f92672>=</span> pown x y
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> memoizedPower <span style=color:#f92672>=</span> memoizeMultiArgs power
</span></span></code></pre></div><p>The <code>memoizeMultiArgs</code> function creates a composite key from the arguments (x, y), allowing the cache to store results for each unique pair. When the same (x, y) pair is passed again, the function immediately returns the cached result, avoiding the need for recalculating the power.</p><h3 id=implementing-memoization-with-immutable-data-structures>Implementing Memoization with Immutable Data Structures</h3><p>F#‚Äôs immutable data structures encourage developers to write <em><strong>side-effect-free functions</strong></em>, which are ideal for memoization. By eliminating side effects, we ensure that the cached results are predictable and stable over the lifetime of the program.</p><p>If you prefer not to use mutable dictionaries, you can implement memoization with an immutable map (e.g., <code>Map</code> in F#). The caveat with using immutable structures means that each time a new value is added to the cache, a new map is created. This can impact performance for larger datasets. For most applications, the mutable dictionary approach is more efficient.</p><h3 id=memoization-with-lazy-evaluation-in-f>Memoization with Lazy Evaluation in F#</h3><p>Memoization and lazy evaluation are complementary techniques that work well together. Lazy evaluation defers computation until the result is needed, while memoization ensures that repeated calls with the same arguments are cached.</p><p>In F#, we can combine lazy evaluation with memoization by wrapping values in the <code>lazy</code> keyword:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fsharp data-lang=fsharp><span style=display:flex><span><span style=color:#66d9ef>let</span> memoizeLazy f <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> cache <span style=color:#f92672>=</span> System.Collections.Generic.Dictionary<span style=color:#f92672>&lt;_,</span> Lazy<span style=color:#f92672>&lt;_&gt;&gt;</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fun</span> x <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> cache<span style=color:#f92672>.</span>TryGetValue<span style=color:#f92672>(</span>x<span style=color:#f92672>)</span> <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>,</span> lazyResult <span style=color:#f92672>-&gt;</span> lazyResult<span style=color:#f92672>.</span>Value
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> lazyResult <span style=color:#f92672>=</span> <span style=color:#66d9ef>lazy</span> <span style=color:#f92672>(</span>f x<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>            cache<span style=color:#f92672>.[</span>x<span style=color:#f92672>]</span> <span style=color:#f92672>&lt;-</span> lazyResult
</span></span><span style=display:flex><span>            lazyResult<span style=color:#f92672>.</span>Value
</span></span></code></pre></div><p>This function memoizes <code>f</code> in a lazy way - only evaluating and caching the result when <code>lazyResult.Value</code> is called for the first time. This can be particularly helpful in applications where computations are costly, but some cached values may never actually be used.</p><h3 id=memoization-in-functional-pipelines>Memoization in Functional Pipelines</h3><p>In F#, we often compose functions into pipelines to handle complex data transformations. Memoization can help optimize these pipelines by storing intermediate results.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fsharp data-lang=fsharp><span style=display:flex><span><span style=color:#66d9ef>let</span> memoizePipeline f <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> cache <span style=color:#f92672>=</span> System.Collections.Generic.Dictionary<span style=color:#f92672>&lt;_,</span> <span style=color:#f92672>_&gt;</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fun</span> x <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> cache<span style=color:#f92672>.</span>ContainsKey<span style=color:#f92672>(</span>x<span style=color:#f92672>)</span> <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>            cache<span style=color:#f92672>.[</span>x<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> f x
</span></span><span style=display:flex><span>            cache<span style=color:#f92672>.[</span>x<span style=color:#f92672>]</span> <span style=color:#f92672>&lt;-</span> result
</span></span><span style=display:flex><span>            result
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> expensiveTransformation x <span style=color:#f92672>=</span> 
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Imagine some complex computation here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    x <span style=color:#f92672>*</span> x <span style=color:#f92672>+</span> 42
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> memoizedTransformation <span style=color:#f92672>=</span> memoizePipeline expensiveTransformation
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> results <span style=color:#f92672>=</span> <span style=color:#f92672>[</span>1<span style=color:#f92672>..</span>10<span style=color:#f92672>]</span> <span style=color:#f92672>|&gt;</span> List.map memoizedTransformation
</span></span></code></pre></div><p><code>expensiveTransformation</code> here is wrapped in a memoized function to ensure the transformation is only calculated once for each unique input in the pipeline. This approach can be scaled to handle multiple transformations or can be applied selectively to certain stages within the pipeline.</p><h3 id=memoization-in-dynamic-programming-solving-the-knapsack-problem>Memoization in Dynamic Programming: Solving the Knapsack Problem</h3><p>Dynamic programming involves solving complex problems by breaking them down into smaller overlapping subproblems. This makes it a good use-case for momoization. Consider the classic <strong>Knapsack problem</strong>, where we have to maximize the value of items that fit into a bag with a fixed capacity. Memoization allows us to avoid recalculating values for subproblems that have already been solved as illustrated below:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fsharp data-lang=fsharp><span style=display:flex><span><span style=color:#66d9ef>let</span> knapsack <span style=color:#f92672>(</span>items<span style=color:#f92672>:</span> <span style=color:#f92672>(</span>int <span style=color:#f92672>*</span> int<span style=color:#f92672>)</span> <span style=color:#66d9ef>list</span><span style=color:#f92672>)</span> capacity <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> rec ks n cap <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> n <span style=color:#f92672>=</span> 0 <span style=color:#f92672>||</span> cap <span style=color:#f92672>=</span> 0 <span style=color:#66d9ef>then</span> 0
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#f92672>(</span>weight<span style=color:#f92672>,</span> value<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> items<span style=color:#f92672>.[</span>n <span style=color:#f92672>-</span> 1<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> weight <span style=color:#f92672>&gt;</span> cap <span style=color:#66d9ef>then</span> ks <span style=color:#f92672>(</span>n <span style=color:#f92672>-</span> 1<span style=color:#f92672>)</span> cap
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> max <span style=color:#f92672>(</span>ks <span style=color:#f92672>(</span>n <span style=color:#f92672>-</span> 1<span style=color:#f92672>)</span> cap<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>value <span style=color:#f92672>+</span> ks <span style=color:#f92672>(</span>n <span style=color:#f92672>-</span> 1<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>cap <span style=color:#f92672>-</span> weight<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>    memoizeMultiArg ks <span style=color:#f92672>(</span>List.length items<span style=color:#f92672>)</span> capacity
</span></span></code></pre></div><p>In this example, <code>ks</code> is the recursive function for calculating the maximum knapsack value. By memoizing the recursive calls, we eliminate redundant calculations, which improves efficiency significantly.</p><blockquote><p>With memoization, you can create functions that perform better while maintaining immutability and referential transparency - hallmarks of functional programming.</p></blockquote><p>With a good understanding of memoization, let&rsquo;s look at another real world example in solving the Fibonacci sequence.</p><br><h3 id=the-fibonacci-sequence>The Fibonacci Sequence</h3><p>Akin to factorials, we can easily use a <strong>Fibonacci sequence</strong> to better illustrate memoization. The Fibonacci sequence starts with two 1‚Äôs, and each subsequent number is the sum of the two preceding numbers:</p><p>1,1,2,3,5,8,13,&mldr;</p><p>In mathematical terms, it‚Äôs written as:</p><p><em><strong>F<sub>n</sub> = F<sub>n-1</sub> + F<sub>n-2</sub></strong></em></p><p>Which can also be written recursively as:</p><p><em><strong>F<sub>n</sub> = F<sub>n-1</sub> + F<sub>n+2</sub></strong><br><strong>F<sub>0</sub> = 0</strong><br><strong>F<sub>1</sub> = 1</strong><br><strong>F<sub>n</sub> = F<sub>n</sub> - 1 + F<sub>n</sub> - 2, if n > 1</strong><br><strong>F<sub>n</sub> = F<sub>n</sub> + 2 - F<sub>n</sub> -1 , if n > 0</strong></em></p><p>Starting with ùêπ<sub>(1)</sub>=1 and F<sub>(2)</sub>=1, the sequence builds itself naturally as 1, 1, 2, 3, 5, 8, and so on. Computing Fibonacci numbers recursively without optimization is however inefficient, since each recursive call redundantly recalculates already-known values. Memoization can significantly reduce computation time by storing results of previous calls in a cache, reusing these values as needed.</p><p>Let‚Äôs start with the most straightforward implementation of Fibonacci in F# using recursion:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fsharp data-lang=fsharp><span style=display:flex><span><span style=color:#66d9ef>let</span> rec fibonacci n <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> n <span style=color:#f92672>&lt;=</span> 2 <span style=color:#66d9ef>then</span> 1
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> fibonacci <span style=color:#f92672>(</span>n <span style=color:#f92672>-</span> 1<span style=color:#f92672>)</span> <span style=color:#f92672>+</span> fibonacci <span style=color:#f92672>(</span>n <span style=color:#f92672>-</span> 2<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>This approach above appears intuitive but is not optimized. Each call to <code>fibonacci</code> results in two additional calls until we reach the base cases. As <code>n</code> tends towards infinity, this redundancy leads to <strong>exponential time complexity</strong>, where the same values are recalculated many times. If we were to call <code>fibonacci 50</code>, it would take considerable time due to repeated calculations.</p><h4 id=optimizing-with-tail-recursion>Optimizing with Tail Recursion</h4><p>Tail recursion is a common functional programming technique that allows functions to call themselves recursively without increasing the call stack. We can therefore avoid the stack overflow that a basic recursive function would cause on large inputs by passing the accumulated result along with each recursive call. Here‚Äôs an F# implementation of a tail-recursive Fibonacci function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fsharp data-lang=fsharp><span style=display:flex><span><span style=color:#66d9ef>let</span> fibonacci_TailRecursive n <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> rec fibonacciX <span style=color:#f92672>(</span>n<span style=color:#f92672>,</span> x<span style=color:#f92672>,</span> y<span style=color:#f92672>)</span> <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> n <span style=color:#f92672>=</span> 0 <span style=color:#66d9ef>then</span> x
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> fibonacciX <span style=color:#f92672>(</span>n <span style=color:#f92672>-</span> 1<span style=color:#f92672>,</span> y<span style=color:#f92672>,</span> x <span style=color:#f92672>+</span> y<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    fibonacciX <span style=color:#f92672>(</span>n<span style=color:#f92672>,</span> 0<span style=color:#f92672>,</span> 1<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>In the improved version:</p><ul><li><code>fibonacciX</code> is our <strong>inner recursive</strong> function.</li><li><code>x</code> and <code>y</code> represent two consecutive Fibonacci numbers in the sequence.</li><li>Each recursive call reduces <code>n</code> by <code>1</code>, adding the current and previous results together <code>(x + y)</code> until <code>n</code> reaches zero.</li></ul><p>This is a more efficient implementation that won‚Äôt cause a stack overflow, but it can still be improved in terms of performance by leveraging memoization.</p><h4 id=memoization-reducing-redundant-computation>Memoization: Reducing Redundant Computation</h4><p>As in our initial code, we can implement memoization by creating a cache using a dictionary. This dictionary will store computed Fibonacci values and allow us to return cached results for repeated inputs instantly.</p><p>Using a dictionary for our cache, we can rewrite the Fibonacci function with memoization as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fsharp data-lang=fsharp><span style=display:flex><span><span style=color:#66d9ef>open</span> System.Collections.Generic
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> fibonacci_Memoized <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> cache <span style=color:#f92672>=</span> Dictionary<span style=color:#f92672>&lt;_,</span> <span style=color:#f92672>_&gt;</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> rec fibonacciX <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> n <span style=color:#66d9ef>when</span> n <span style=color:#f92672>=</span> 0I <span style=color:#f92672>-&gt;</span> 0I
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> n <span style=color:#66d9ef>when</span> n <span style=color:#f92672>=</span> 1I <span style=color:#f92672>-&gt;</span> 1I
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> n <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> cache<span style=color:#f92672>.</span>ContainsKey<span style=color:#f92672>(</span>n<span style=color:#f92672>)</span> <span style=color:#66d9ef>then</span> cache<span style=color:#f92672>.[</span>n<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> fibonacciX <span style=color:#f92672>(</span>n <span style=color:#f92672>-</span> 1I<span style=color:#f92672>)</span> <span style=color:#f92672>+</span> fibonacciX <span style=color:#f92672>(</span>n <span style=color:#f92672>-</span> 2I<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>                cache<span style=color:#f92672>.[</span>n<span style=color:#f92672>]</span> <span style=color:#f92672>&lt;-</span> result
</span></span><span style=display:flex><span>                result
</span></span><span style=display:flex><span>    fibonacciX
</span></span></code></pre></div><p>In this function:</p><ul><li>We use <code>BigInteger</code> (<code>n = 0I</code> and <code>1I</code>), which allows us to work with much larger numbers than standard integers. This is useful for deep recursion in the Fibonacci sequence.</li><li><code>cache</code> stores previously computed Fibonacci numbers. The dictionary‚Äôs syntax, <code>cache.[n]</code>, is the F# equivalent of accessing elements with <code>cache[n]</code> in languages like C# or Java.</li><li>When <code>fibonacciX</code> is called with a value of <code>n</code>, it first checks if <code>n</code> is in the cache. If it is, the cached result is returned immediately, skipping further computation.If not, the function recursively computes the value, adds it to the cache, and then returns it.</li></ul><p>In F#‚Äôs interactive window (FSI), we can evaluate the function‚Äôs performance by using the <code>#time</code> directive to record the execution time of any code following it until <code>#time</code> is called again. For example, we can test out function above as:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fsharp data-lang=fsharp><span style=display:flex><span><span style=color:#f92672>#</span>time
</span></span><span style=display:flex><span>fibonacci_Memoized 20I
</span></span><span style=display:flex><span><span style=color:#f92672>#</span>time
</span></span></code></pre></div><h3 id=benefits-and-limitations-of-memoization>Benefits and Limitations of Memoization</h3><p>Memoization isn‚Äôt a one-size-fits-all solution. Its key advantages include:</p><ul><li><strong>Reduced Time Complexity</strong> where functions can avoid exponential time growth and execute in linear time for overlapping subproblems by storing previous computations for re-use.</li><li><strong>Improved Efficiency</strong>: Repeated inputs result in constant-time lookups in the cache, providing significant speedup.</li><li><strong>Scalability for Recursion</strong>: Memoization helps avoid stack overflow issues, particularly when combined with tail recursion for complex recursive functions.</li></ul><p>That being said, there are a few trade-offs:</p><ul><li><strong>Increased Memory Usage</strong>: Caching comes at the cost of additional memory. For very large inputs, the cache can consume a significant amount of memory.</li><li><strong>Not Always Suitable</strong>: Memoization is ideal for deterministic functions where inputs consistently map to the same outputs. It‚Äôs less effective (or entirely unsuitable) for non-deterministic functions or those with many unique inputs that don‚Äôt repeat.</li></ul><h3 id=exploring-other-optimization-techniques-in-f>Exploring Other Optimization techniques in F#</h3><p>Memoization is just one of many optimizations in F#. Other techniques such <strong>continuations</strong> and <strong>higher-order functions</strong> can also improve performance and readability in functional code. The ultimate solution involves combining these techniques to yield optimal results, though there‚Äôs no universal rule for selecting the best approach. Here are some points to consider when deciding on an optimization technique:</p><ul><li><strong>Data Variability</strong>: For highly variable data where inputs rarely repeat, memoization may not be as useful.</li><li><strong>Memory Constraints</strong>: If your program has limited memory availability, consider optimizing your cache size or limiting the range of cached results.</li><li><strong>Clarity vs. Performance</strong>: Memoization can make code less readable, especially in complex functions. It&rsquo;s important to always weigh clarity against performance requirements especially if the function is a core part of your application.</li></ul><br><br><p>In conclusion, Memoization is a valuable optimization technique for recursive problems like the Fibonacci sequence. By caching computed results memoization helps reduce redundant computations, improve execution time, and enable functions to handle larger inputs faster. In F#, memoization aligns well with the language‚Äôs functional programming paradigm and can be paired with other optimizations like <strong>tail recursion</strong> to further enhance performance.</p></div><div class="row ps-3 pe-3"><div class="col-md-6 share-buttons"><strong>Share on:</strong>
<a class="btn icon-button bg-facebook" href="https://www.facebook.com/sharer.php?u=https%3a%2f%2fcarlvinjerry.github.io%2fposts%2fprogramming%2fcode-sustainability%2fsuccint-fsharp%2fmemoization%2f" target=_blank><i class="fab fa-facebook"></i>
</a><a class="btn icon-button bg-twitter" href="https://twitter.com/share?url=https%3a%2f%2fcarlvinjerry.github.io%2fposts%2fprogramming%2fcode-sustainability%2fsuccint-fsharp%2fmemoization%2f&text=Memoization%20with%20Fibonacci&via=R%ce%9eCURSION" target=_blank><i class="fab fa-twitter"></i>
</a><a class="btn icon-button bg-reddit" href="https://reddit.com/submit?url=https%3a%2f%2fcarlvinjerry.github.io%2fposts%2fprogramming%2fcode-sustainability%2fsuccint-fsharp%2fmemoization%2f&title=Memoization%20with%20Fibonacci" target=_blank><i class="fab fa-reddit"></i>
</a><a class="btn icon-button bg-linkedin" href="https://www.linkedin.com/shareArticle?url=https%3a%2f%2fcarlvinjerry.github.io%2fposts%2fprogramming%2fcode-sustainability%2fsuccint-fsharp%2fmemoization%2f&title=Memoization%20with%20Fibonacci" target=_blank><i class="fab fa-linkedin"></i>
</a><a class="btn icon-button bg-mastodon" href="https://mastodon.social/share?text=Memoization%20with%20Fibonacci - https%3a%2f%2fcarlvinjerry.github.io%2fposts%2fprogramming%2fcode-sustainability%2fsuccint-fsharp%2fmemoization%2f" target=_blank><i class="fab fa-mastodon"></i>
</a><a class="btn icon-button bg-whatsapp" href="https://api.whatsapp.com/send?text=Memoization%20with%20Fibonacci https%3a%2f%2fcarlvinjerry.github.io%2fposts%2fprogramming%2fcode-sustainability%2fsuccint-fsharp%2fmemoization%2f" target=_blank><i class="fab fa-whatsapp"></i>
</a><a class="btn icon-button" href="mailto:?subject=Memoization%20with%20Fibonacci&body=https%3a%2f%2fcarlvinjerry.github.io%2fposts%2fprogramming%2fcode-sustainability%2fsuccint-fsharp%2fmemoization%2f" target=_blank><i class="fas fa-envelope-open-text"></i></a></div><div class="col-md-6 btn-improve-page"><a href=https://github.com/carlvinjerry/carlvinjerry.github.io/edit/main/content/posts/programming/Code-Sustainability/Succint%20FSharp/memoization/index.md title="Improve this page" target=_blank rel=noopener><i class="fas fa-code-branch"></i>
Improve this page</a></div></div><hr><div class="row next-prev-navigator"><div class="col-md-6 previous-article"><a href=/posts/programming/code-sustainability/succint-fsharp/working-with-paket/ title="A Better Way to Manage Dependencies in F#" class="btn filled-button"><div><i class="fas fa-chevron-circle-left"></i> Prev</div><div class=next-prev-text>A Better Way to Manage Dependencies in F#</div></a></div><div class="col-md-6 next-article"><a href=/posts/programming/code-sustainability/succint-fsharp/pattern-matching/ title=" Optimizing Pattern Matching in F# for Better Performance " class="btn filled-button"><div>Next <i class="fas fa-chevron-circle-right"></i></div><div class=next-prev-text>Optimizing Pattern Matching in F# for Better Performance</div></a></div></div><hr><div id=disqus_thread></div><script type=text/javascript>(function(){if(window.location.hostname=="localhost")return;var t,e=document.createElement("script");e.type="text/javascript",e.async=!0,t="i_carlvin",e.src="//"+t+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)})()</script><noscript>Please enable JavaScript to view the
<a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com/ class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></div><a id=scroll-to-top class=btn type=button data-bs-toggle=tooltip data-bs-placement=left title="Scroll to top"><i class="fas fa-chevron-circle-up"></i></a></section><section class=toc-section id=toc-section><div class=toc-holder><h5 class="text-center ps-3">Table of Contents</h5><hr><div class=toc><nav id=TableOfContents><ul><li><ul><li><ul><li><a href=#why-memoization-matters>Why Memoization Matters</a></li></ul></li><li><a href=#basic-memoization-in-f>Basic Memoization in F#</a></li><li><a href=#advanced-memoization-with-higher-order-functions>Advanced Memoization with Higher-Order Functions</a><ul><li><a href=#example-memoizing-a-multi-argument-function>Example: Memoizing a Multi-Argument Function</a></li></ul></li><li><a href=#implementing-memoization-with-immutable-data-structures>Implementing Memoization with Immutable Data Structures</a></li><li><a href=#memoization-with-lazy-evaluation-in-f>Memoization with Lazy Evaluation in F#</a></li><li><a href=#memoization-in-functional-pipelines>Memoization in Functional Pipelines</a></li><li><a href=#memoization-in-dynamic-programming-solving-the-knapsack-problem>Memoization in Dynamic Programming: Solving the Knapsack Problem</a></li><li><a href=#the-fibonacci-sequence>The Fibonacci Sequence</a><ul><li><a href=#optimizing-with-tail-recursion>Optimizing with Tail Recursion</a></li><li><a href=#memoization-reducing-redundant-computation>Memoization: Reducing Redundant Computation</a></li></ul></li><li><a href=#benefits-and-limitations-of-memoization>Benefits and Limitations of Memoization</a></li><li><a href=#exploring-other-optimization-techniques-in-f>Exploring Other Optimization techniques in F#</a></li></ul></li></ul></nav></div></div></section></div><footer id=footer class="container-fluid text-center align-content-center footer pb-2"><div class="container pt-5"><div class="row text-start"><div class="col-md-4 col-sm-12"><h5>Navigation</h5><ul><li class=nav-item><a class=smooth-scroll href=https://carlvinjerry.github.io/#about>About</a></li><li class=nav-item><a class=smooth-scroll href=https://carlvinjerry.github.io/#recent-posts>Recent Posts</a></li><li class=nav-item><a class=smooth-scroll href=https://carlvinjerry.github.io/#projects>Projects</a></li></ul></div><div class="col-md-4 col-sm-12"><h5>Contact me:</h5><ul><li><a href=mailto:carlvinjerry@gmail.com%20%7c%20cmwange@beyondrawdata.co.ke target=_blank rel=noopener><span><i class="fas fa-envelope"></i></span> <span>carlvinjerry@gmail.com | cmwange@beyondrawdata.co.ke</span></a></li><li><a href=https://github.com/carlvinjerry target=_blank rel=noopener><span><i class="fab fa-github"></i></span> <span>carlvinjerry</span></a></li><li><a href=https://www.linkedin.com/in/carlvinmwange target=_blank rel=noopener><span><i class="fab fa-linkedin"></i></span> <span>Carlvin Jerry Mwange</span></a></li><li><a href=tel:+254%20%280%29747%20942%20588 target=_blank rel=noopener><span><i class="fas fa-phone-alt"></i></span> <span>+254 (0)747 942 588</span></a></li><li><a href=https://www.researchgate.net/profile/carlvinmwange target=_blank rel=noopener><span><i class="fab fa-researchgate"></i></span> <span>Carlvin Jerry Mwange</span></a></li></ul></div></div></div><hr><div class=container><p id=disclaimer><strong>Liability Notice:</strong> This theme is under MIT license. So, you can use it for non-commercial, commercial, or private uses. You can modify or distribute the theme without requiring any permission from the theme author. However, the theme author does not provide any warranty or takes any liability for any issue with the theme.</p></div><hr><div class=container><div class="row text-start"><div class=col-md-4><a id=theme href=https://github.com/hugo-toha/toha target=_blank rel=noopener><img src=/images/theme-logo_hu16779671404603505019.png alt="Toha Theme Logo">
Toha</a></div><div class="col-md-4 text-center">¬© 2020 Copyright.</div><div class="col-md-4 text-end"><a id=hugo href=https://gohugo.io/ target=_blank rel=noopener>Powered by
<img src=/images/hugo-logo.svg alt="Hugo Logo" height=18></a></div></div></div></footer><script src=/application.b1192b27bb9da1367104dd2311a23a6f78cc8e16c840ce3f8406443569df5b65.js integrity="sha256-sRkrJ7udoTZxBN0jEaI6b3jMjhbIQM4/hAZENWnfW2U=" defer></script></body></html>