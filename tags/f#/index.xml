<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>F# on RΞCURSION</title><link>https://carlvinjerry.github.io/tags/f%23/</link><description>Recent content in F# on RΞCURSION</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sat, 09 Aug 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://carlvinjerry.github.io/tags/f%23/index.xml" rel="self" type="application/rss+xml"/><item><title>Introduction to Stochastic Differential Equations</title><link>https://carlvinjerry.github.io/posts/quantitative-finance/intro-to-sdes/</link><pubDate>Sat, 09 Aug 2025 00:00:00 +0000</pubDate><guid>https://carlvinjerry.github.io/posts/quantitative-finance/intro-to-sdes/</guid><description>This post introduces SDEs and the Euler-Maruyama method, demonstrating their application in finance and ESG modeling. Through F# simulations of stock prices and renewable energy adoption, we show how to implement and visualize SDE solutions, highlighting their importance for handling uncertainty.</description></item><item><title>Seamless R Integration in .NET with R.NET: A Step-by-Step Guide</title><link>https://carlvinjerry.github.io/posts/programming/interoperability/rdotnet-interop/</link><pubDate>Mon, 04 Aug 2025 16:54:25 +0600</pubDate><guid>https://carlvinjerry.github.io/posts/programming/interoperability/rdotnet-interop/</guid><description>This post explores how R.NET enables seamless in-process R integration in .NET, focusing on statistical computations. Through a simple F# example calculating mean and standard deviation, we demonstrate how to set up R.NET, call R functions, and handle common pitfalls, empowering .NET developers to leverage R’s power.</description></item><item><title>Modelling Relationships in F# for Domain-Driven Design</title><link>https://carlvinjerry.github.io/posts/programming/functional-programming/discriminated-unions/</link><pubDate>Mon, 21 Jul 2025 08:06:25 +0600</pubDate><guid>https://carlvinjerry.github.io/posts/programming/functional-programming/discriminated-unions/</guid><description>This post explores F#&amp;rsquo;s discriminated unions for domain-driven design, focusing on financial systems. Through examples like modeling financial instruments, transactions, and account types, we demonstrate how to encode business rules, ensure type safety, and simplify complex domains using F#.</description></item><item><title>Understanding Functors and Monads in F# with Statistical and Financial Models</title><link>https://carlvinjerry.github.io/posts/programming/functional-programming/monads/</link><pubDate>Mon, 28 Apr 2025 08:06:25 +0600</pubDate><guid>https://carlvinjerry.github.io/posts/programming/functional-programming/monads/</guid><description>This blog post demystifies functors and monads in F# through real-world statistical and financial modeling examples. Learn how Option, Result, and Async types simplify handling missing data, errors, and asynchronous computations, enabling robust and composable code for data processing, risk modeling, and Monte Carlo simulations.</description></item><item><title>What’s New in F# 9 for Quant Developers</title><link>https://carlvinjerry.github.io/posts/programming/languages/fsharp/fsharp-9-review/</link><pubDate>Wed, 23 Apr 2025 19:51:10 +0300</pubDate><guid>https://carlvinjerry.github.io/posts/programming/languages/fsharp/fsharp-9-review/</guid><description>Unlike general-purpose updates, many of F# 9&amp;rsquo;s features are particularly well-aligned with the needs of quantitative professionals—those who balance mathematical modeling, financial computation, and high-integrity codebases. These improvements refine the language’s functional core while addressing practical challenges faced in real-world applications, such as code readability, workflow modularity, and precision in data modeling.
In this post, I’ll walk through some of the key updates in F# 9 and explore how they can improve the way we write and structure quantitative code.</description></item><item><title> Optimizing Pattern Matching in F# for Better Performance</title><link>https://carlvinjerry.github.io/posts/programming/code-sustainability/succint-fsharp/pattern-matching/</link><pubDate>Mon, 03 Mar 2025 21:37:25 +0600</pubDate><guid>https://carlvinjerry.github.io/posts/programming/code-sustainability/succint-fsharp/pattern-matching/</guid><description>Pattern matching is one of the most powerful features of functional we can employ to ensure more expressive and easier-to-read code. However, handling large data structures may require optimal pattern matching to avoid performance. This article explores techniques to optimize pattern matching in F# by minimizing unnecessary computations and improving efficiency.
Common Performance Issues in Pattern Matching Although pattern matching improves code readability, improper use can lead to inefficiencies. Some common issues include:</description></item><item><title>Memoization with Fibonacci</title><link>https://carlvinjerry.github.io/posts/programming/code-sustainability/succint-fsharp/memoization/</link><pubDate>Mon, 04 Nov 2024 21:37:25 +0600</pubDate><guid>https://carlvinjerry.github.io/posts/programming/code-sustainability/succint-fsharp/memoization/</guid><description>Memoization, commonly known as caching is a key technique we can use for performance optimization in programming. Memoization simply stores the results from a previous computation for later retrieval whenever the arguments are presented again. The ability to re-use these, often expensive functions, brings significant performance improvements - especially in scenarios with repetitive computations. In F#, memoization is not only a helpful optimization but also a natural fit due to the language’s immutable data structures and functional nature.</description></item><item><title>A Better Way to Manage Dependencies in F#</title><link>https://carlvinjerry.github.io/posts/programming/code-sustainability/succint-fsharp/working-with-paket/</link><pubDate>Tue, 22 Oct 2024 21:37:25 +0600</pubDate><guid>https://carlvinjerry.github.io/posts/programming/code-sustainability/succint-fsharp/working-with-paket/</guid><description>The default go-to tool for most .Net developers is NuGet. It simplifies handling dependencies across projects and also provides a central reference point for reusable .Net components. Due to its initial development and growth over time, NuGet poses a few shortcomings evident over the years. As an alternative, specifically for F# developers, Paket is an open source dependency manager for .Net projects that was originally built with the primary goal of addressing some of the shortcomings developers encountered when managing dependencies in large and complex projects.</description></item><item><title>Currying and Partial Application in F#</title><link>https://carlvinjerry.github.io/posts/programming/code-sustainability/succint-fsharp/currying/</link><pubDate>Mon, 07 Oct 2024 08:06:25 +0600</pubDate><guid>https://carlvinjerry.github.io/posts/programming/code-sustainability/succint-fsharp/currying/</guid><description>The mathematical definition of a function can be denoted as a relationship between a set of inputs (the domain) and a single output (the co-domain). When a mathematical function is said to have only one parameter, it typically means that it takes a single value as input. However, in functional programming we build functions that theoretically &amp;ldquo;defy&amp;rdquo; this concept by taking in multiple input parameters.
Traditionally, a mathematical function may only accept one input at a time.</description></item><item><title>Enhancing Code Maintainability with the F# 'Option' Type</title><link>https://carlvinjerry.github.io/posts/programming/code-sustainability/succint-fsharp/fs-option-type/</link><pubDate>Tue, 17 Sep 2024 08:06:25 +0600</pubDate><guid>https://carlvinjerry.github.io/posts/programming/code-sustainability/succint-fsharp/fs-option-type/</guid><description>A common case in programming is handling variables that might or might not hold a value. The C# language for example, uses Nullable&amp;lt;T&amp;gt; to represent such cases. This enables you to declare variables as nullables that would otherwise not be assigned to Nulls (e.g a float or an int). Handling these null references in languages like C# or Java can often lead to bugs. A clean and powerful solution to this problem is provided in F#: the Option type.</description></item></channel></rss>