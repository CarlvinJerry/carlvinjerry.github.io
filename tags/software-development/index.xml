<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Software Development on RΞCURSION</title><link>https://carlvinjerry.github.io/tags/software-development/</link><description>Recent content in Software Development on RΞCURSION</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 03 Mar 2025 21:37:25 +0600</lastBuildDate><atom:link href="https://carlvinjerry.github.io/tags/software-development/index.xml" rel="self" type="application/rss+xml"/><item><title> Optimizing Pattern Matching in F# for Better Performance</title><link>https://carlvinjerry.github.io/posts/programming/code-sustainability/succint-fsharp/pattern-matching/</link><pubDate>Mon, 03 Mar 2025 21:37:25 +0600</pubDate><guid>https://carlvinjerry.github.io/posts/programming/code-sustainability/succint-fsharp/pattern-matching/</guid><description>Pattern matching is one of the most powerful features of functional we can employ to ensure more expressive and easier-to-read code. However, handling large data structures may require optimal pattern matching to avoid performance. This article explores techniques to optimize pattern matching in F# by minimizing unnecessary computations and improving efficiency.
Common Performance Issues in Pattern Matching Although pattern matching improves code readability, improper use can lead to inefficiencies. Some common issues include:</description></item><item><title>Memoization with Fibonacci</title><link>https://carlvinjerry.github.io/posts/programming/code-sustainability/succint-fsharp/memoization/</link><pubDate>Mon, 04 Nov 2024 21:37:25 +0600</pubDate><guid>https://carlvinjerry.github.io/posts/programming/code-sustainability/succint-fsharp/memoization/</guid><description>Memoization, commonly known as caching is a key technique we can use for performance optimization in programming. Memoization simply stores the results from a previous computation for later retrieval whenever the arguments are presented again. The ability to re-use these, often expensive functions, brings significant performance improvements - especially in scenarios with repetitive computations. In F#, memoization is not only a helpful optimization but also a natural fit due to the language’s immutable data structures and functional nature.</description></item><item><title>A Better Way to Manage Dependencies in F#</title><link>https://carlvinjerry.github.io/posts/programming/code-sustainability/succint-fsharp/working-with-paket/</link><pubDate>Tue, 22 Oct 2024 21:37:25 +0600</pubDate><guid>https://carlvinjerry.github.io/posts/programming/code-sustainability/succint-fsharp/working-with-paket/</guid><description>The default go-to tool for most .Net developers is NuGet. It simplifies handling dependencies across projects and also provides a central reference point for reusable .Net components. Due to its initial development and growth over time, NuGet poses a few shortcomings evident over the years. As an alternative, specifically for F# developers, Paket is an open source dependency manager for .Net projects that was originally built with the primary goal of addressing some of the shortcomings developers encountered when managing dependencies in large and complex projects.</description></item></channel></rss>